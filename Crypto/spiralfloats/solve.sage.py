

# This file was *autogenerated* from the file solve.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1024 = Integer(1024); _sage_const_1 = Integer(1); _sage_const_5 = Integer(5); _sage_const_2 = Integer(2); _sage_const_0 = Integer(0); _sage_const_81 = Integer(81); _sage_const_1en20 = RealNumber('1e-20'); _sage_const_4 = Integer(4); _sage_const_1en5 = RealNumber('1e-5'); _sage_const_30 = Integer(30); _sage_const_8 = Integer(8); _sage_const_16 = Integer(16); _sage_const_25 = Integer(25); _sage_const_33 = Integer(33); _sage_const_42 = Integer(42); _sage_const_50 = Integer(50); _sage_const_59 = Integer(59); _sage_const_10 = Integer(10); _sage_const_67 = Integer(67)
from Crypto.Util.number import bytes_to_long, long_to_bytes
from sage.all import RealField, sqrt
import string

R = RealField(_sage_const_1024 )
phi = R((_sage_const_1  + sqrt(_sage_const_5 )) / _sage_const_2 )

masked_str = "?7086013?3756162?51694057?5285516?54803756?9202316?39221780?4895755?50591029"
current_chars = list(masked_str)
current_chars[_sage_const_0 ] = '6' 
filled_chars = [c if c != '?' else '0' for c in current_chars]

def inverse_spiral(y_final, phi, iterations=_sage_const_81 ):
    def step(y_val, idx):
        N = R(iterations)
        i = R(idx)
        r = i / N
        C = y_val - (_sage_const_1 -r)*phi
        if idx == _sage_const_0 : return y_val - phi
        A = r**_sage_const_2  - (_sage_const_1 -r)**_sage_const_2 
        B = _sage_const_2  * C * (_sage_const_1 -r)
        D = r**_sage_const_2  - C**_sage_const_2 
        if abs(A) < _sage_const_1en20 : return -D/B
        delta = B**_sage_const_2  - _sage_const_4 *A*D
        if delta < _sage_const_0 : return R(_sage_const_0 ) 
        sqrt_delta = sqrt(delta)
        sol1 = (-B + sqrt_delta) / (_sage_const_2 *A)
        sol2 = (-B - sqrt_delta) / (_sage_const_2 *A)
        def check(x_cand):
            val = r * sqrt(x_cand**_sage_const_2  + _sage_const_1 ) + (_sage_const_1  - r) * (x_cand + phi)
            return abs(val - y_val) < _sage_const_1en5 
        if check(sol1): return sol1
        if check(sol2): return sol2
        return max(sol1, sol2)

    x = y_final
    for i in reversed(range(iterations)):
        x = step(x, i)
    return x

N_best = _sage_const_30 
dummy = b'0xL4ugh{' + b'\x00' * (N_best - _sage_const_8 )
flen_est = len(str(bytes_to_long(dummy)))

def check_bytes(x_val):
    s = str(x_val)
    if s.startswith("0."): s = s[_sage_const_2 :]
    val = int(s[:flen_est])
    try:
        b = long_to_bytes(val)
        return b
    except:
        return b''

best_chars = list(filled_chars)
best_chars[_sage_const_8 ] = '5'
best_chars[_sage_const_16 ] = '5'
best_chars[_sage_const_25 ] = '9' 
best_chars[_sage_const_33 ] = '3' 
best_chars[_sage_const_42 ] = '3' 
best_chars[_sage_const_50 ] = '5'
best_chars[_sage_const_59 ] = '6'

# Inspect Hole 67
print("\nHole 67 Candidates (assuming d50=5, d59=6):")
for d in range(_sage_const_10 ):
    test_chars = list(best_chars)
    test_chars[_sage_const_67 ] = str(d)
    y = R("".join(test_chars)[:_sage_const_2 ] + "." + "".join(test_chars)[_sage_const_2 :])
    x = inverse_spiral(y, phi)
    b = check_bytes(x)
    print(f"d={d}: {b}")

